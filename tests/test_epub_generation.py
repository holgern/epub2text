"""
Tests for epub2text using dynamically generated EPUB files with pypub3.

These tests create EPUB files programmatically and verify that epub2text
can correctly extract text from them.
"""

from pathlib import Path
from typing import cast

import pytest

import pypub  # type: ignore[import-untyped]

from epub2text import EPUBParser, epub2txt


class TestGeneratedEpub:
    """Test epub2text with EPUBs generated by pypub3."""

    @pytest.fixture
    def simple_epub(self, tmp_path: Path) -> Path:
        """Create a simple EPUB with a few chapters."""
        epub_path = tmp_path / "simple_book.epub"

        book = pypub.Epub("Simple Test Book", creator="Test Author")

        # Create chapters with simple HTML content
        chapter1 = pypub.create_chapter_from_text(
            "This is the first chapter.\n\nIt has multiple paragraphs.\n\n"
            "Each paragraph should be preserved.",
            title="Chapter 1: Introduction",
        )

        chapter2 = pypub.create_chapter_from_text(
            "The second chapter continues the story.\n\n"
            "More content follows here.\n\n"
            "And even more text to test extraction.",
            title="Chapter 2: The Middle",
        )

        chapter3 = pypub.create_chapter_from_text(
            "Finally, the conclusion.\n\nThis is the end of our test book.",
            title="Chapter 3: Conclusion",
        )

        book.add_chapter(chapter1)
        book.add_chapter(chapter2)
        book.add_chapter(chapter3)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def html_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with HTML-formatted chapters."""
        epub_path = tmp_path / "html_book.epub"

        book = pypub.Epub("HTML Test Book", creator="HTML Author")

        # Create chapter from HTML
        html_content = b"""
        <html>
        <head><title>HTML Chapter</title></head>
        <body>
            <h1>Welcome to HTML</h1>
            <p>This is a paragraph with <strong>bold</strong> text.</p>
            <p>This is another paragraph with <em>italic</em> text.</p>
            <ul>
                <li>First item</li>
                <li>Second item</li>
                <li>Third item</li>
            </ul>
            <p>Final paragraph after the list.</p>
        </body>
        </html>
        """

        chapter1 = pypub.create_chapter_from_html(
            html_content,
            title="HTML Chapter",
        )

        book.add_chapter(chapter1)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def multi_paragraph_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with many paragraphs for text extraction testing."""
        epub_path = tmp_path / "paragraphs_book.epub"

        book = pypub.Epub("Paragraphs Test", creator="Paragraph Author")

        # Create content with multiple distinct paragraphs
        paragraphs = [
            "Paragraph one of the test.",
            "Paragraph two with more content.",
            "Paragraph three continues.",
            "Paragraph four is here.",
            "Paragraph five ends this chapter.",
        ]

        chapter = pypub.create_chapter_from_text(
            "\n\n".join(paragraphs),
            title="Many Paragraphs",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_simple_epub_extraction(self, simple_epub: Path) -> None:
        """Test basic text extraction from a simple EPUB."""
        text = cast(str, epub2txt(str(simple_epub)))

        # Verify content is extracted
        assert len(text) > 0
        assert "first chapter" in text.lower()
        assert "second chapter" in text.lower()
        assert "conclusion" in text.lower()

    def test_simple_epub_chapters(self, simple_epub: Path) -> None:
        """Test chapter extraction from a simple EPUB."""
        chapters = cast(list[str], epub2txt(str(simple_epub), outputlist=True))

        # Should have chapters
        assert len(chapters) >= 1
        # At least one chapter should have content
        assert any(len(ch) > 0 for ch in chapters)

    def test_html_epub_extraction(self, html_epub: Path) -> None:
        """Test extraction from HTML-formatted EPUB."""
        text = cast(str, epub2txt(str(html_epub)))

        # Verify HTML content is converted to text
        assert len(text) > 0
        assert "bold" in text.lower() or "paragraph" in text.lower()

    def test_parser_metadata(self, simple_epub: Path) -> None:
        """Test metadata extraction from generated EPUB."""
        parser = EPUBParser(str(simple_epub))
        metadata = parser.get_metadata()

        # Check title and author
        assert metadata.title == "Simple Test Book"
        assert "Test Author" in metadata.authors

    def test_parser_chapters(self, simple_epub: Path) -> None:
        """Test chapter listing from EPUBParser."""
        parser = EPUBParser(str(simple_epub))
        chapters = parser.get_chapters()

        # Should have chapters
        assert len(chapters) >= 1

        # Chapters should have titles and content
        for chapter in chapters:
            assert chapter.title is not None
            assert chapter.id is not None

    def test_extract_specific_chapter(self, simple_epub: Path) -> None:
        """Test extracting a specific chapter by ID."""
        parser = EPUBParser(str(simple_epub))
        chapters = parser.get_chapters()

        if len(chapters) > 0:
            # Extract first chapter
            first_chapter_id = chapters[0].id
            text = parser.extract_chapters([first_chapter_id])

            assert len(text) > 0

    def test_multi_paragraph_extraction(self, multi_paragraph_epub: Path) -> None:
        """Test that multiple paragraphs are properly extracted."""
        text = cast(str, epub2txt(str(multi_paragraph_epub)))

        # Check that paragraphs are present
        assert "paragraph one" in text.lower()
        assert "paragraph five" in text.lower()

    def test_clean_vs_raw_extraction(self, simple_epub: Path) -> None:
        """Test difference between clean and raw extraction."""
        clean_text = cast(str, epub2txt(str(simple_epub), clean=True))
        raw_text = cast(str, epub2txt(str(simple_epub), clean=False))

        # Both should have content
        assert len(clean_text) > 0
        assert len(raw_text) > 0

    def test_outputlist_format(self, simple_epub: Path) -> None:
        """Test that outputlist returns a list of strings."""
        result = epub2txt(str(simple_epub), outputlist=True)

        assert isinstance(result, list)
        assert all(isinstance(item, str) for item in result)


class TestComplexEpub:
    """Test more complex EPUB structures."""

    @pytest.fixture
    def nested_chapters_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with nested chapter structure."""
        epub_path = tmp_path / "nested_book.epub"

        book = pypub.Epub("Nested Chapters Book", creator="Nested Author")

        # Part 1
        part1_intro = pypub.create_chapter_from_text(
            "This is Part 1 of the book.\n\nIt contains multiple chapters.",
            title="Part 1: Beginning",
        )

        chapter1_1 = pypub.create_chapter_from_text(
            "Chapter 1.1 content goes here.\n\nMore details follow.",
            title="Chapter 1.1",
        )

        chapter1_2 = pypub.create_chapter_from_text(
            "Chapter 1.2 continues from 1.1.\n\nAdditional information.",
            title="Chapter 1.2",
        )

        # Part 2
        part2_intro = pypub.create_chapter_from_text(
            "Part 2 begins here.\n\nNew section of the book.",
            title="Part 2: Middle",
        )

        chapter2_1 = pypub.create_chapter_from_text(
            "Chapter 2.1 is the first chapter of Part 2.\n\nContent here.",
            title="Chapter 2.1",
        )

        book.add_chapter(part1_intro)
        book.add_chapter(chapter1_1)
        book.add_chapter(chapter1_2)
        book.add_chapter(part2_intro)
        book.add_chapter(chapter2_1)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def special_chars_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with special characters."""
        epub_path = tmp_path / "special_chars_book.epub"

        book = pypub.Epub("Special Characters Test", creator="Special Author")

        # Content with various special characters
        special_content = (
            "Testing special characters:\n\n"
            "Quotes: 'single' and \"double\"\n\n"
            "Dashes: em-dash and en-dash\n\n"
            "Ellipsis: Wait for it...\n\n"
            "Ampersand: Fish & Chips\n\n"
            "Less/Greater: 5 < 10 > 3\n\n"
            "Unicode: cafe with accent"
        )

        chapter = pypub.create_chapter_from_text(
            special_content,
            title="Special Characters Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def long_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with a long chapter."""
        epub_path = tmp_path / "long_chapter_book.epub"

        book = pypub.Epub("Long Chapter Test", creator="Long Author")

        # Generate long content
        paragraphs = []
        for i in range(50):
            paragraphs.append(
                f"This is paragraph number {i + 1}. "
                f"It contains some text to make the chapter longer. "
                f"Testing extraction of larger content blocks."
            )

        chapter = pypub.create_chapter_from_text(
            "\n\n".join(paragraphs),
            title="A Very Long Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_nested_chapters_extraction(self, nested_chapters_epub: Path) -> None:
        """Test extraction from EPUB with nested chapters."""
        text = cast(str, epub2txt(str(nested_chapters_epub)))

        # Verify all parts are extracted
        assert "part 1" in text.lower()
        assert "part 2" in text.lower()
        assert "chapter 1.1" in text.lower() or "1.1" in text

    def test_special_characters(self, special_chars_epub: Path) -> None:
        """Test that special characters are handled correctly."""
        text = cast(str, epub2txt(str(special_chars_epub)))

        # Basic content should be present
        assert "special characters" in text.lower()
        assert "ampersand" in text.lower() or "&" in text

    def test_long_chapter_extraction(self, long_chapter_epub: Path) -> None:
        """Test extraction of long chapters."""
        text = cast(str, epub2txt(str(long_chapter_epub)))

        # Should have substantial content
        assert len(text) > 1000

        # Should contain content from throughout the chapter
        assert "paragraph number 1" in text.lower()
        assert "paragraph number 50" in text.lower()

    def test_chapter_count(self, nested_chapters_epub: Path) -> None:
        """Test that correct number of chapters are detected."""
        parser = EPUBParser(str(nested_chapters_epub))
        chapters = parser.get_chapters()

        # Should detect multiple chapters
        assert len(chapters) >= 3


class TestEdgeCases:
    """Test edge cases and error handling."""

    @pytest.fixture
    def empty_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with an empty chapter."""
        epub_path = tmp_path / "empty_chapter_book.epub"

        book = pypub.Epub("Empty Chapter Test", creator="Empty Author")

        # One chapter with content
        chapter1 = pypub.create_chapter_from_text(
            "This chapter has content.",
            title="Chapter with Content",
        )

        # One chapter with minimal content
        chapter2 = pypub.create_chapter_from_text(
            " ",
            title="Nearly Empty Chapter",
        )

        book.add_chapter(chapter1)
        book.add_chapter(chapter2)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def single_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with only one chapter."""
        epub_path = tmp_path / "single_chapter_book.epub"

        book = pypub.Epub("Single Chapter Book", creator="Single Author")

        chapter = pypub.create_chapter_from_text(
            "This is the only chapter in the entire book.\n\n"
            "It should still be extracted correctly.",
            title="The Only Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_empty_chapter_handling(self, empty_chapter_epub: Path) -> None:
        """Test that empty chapters don't cause errors."""
        text = cast(str, epub2txt(str(empty_chapter_epub)))

        # Should still get content from non-empty chapter
        assert "has content" in text.lower()

    def test_single_chapter_epub(self, single_chapter_epub: Path) -> None:
        """Test EPUB with only one chapter."""
        text = cast(str, epub2txt(str(single_chapter_epub)))

        assert "only chapter" in text.lower()

    def test_single_chapter_list(self, single_chapter_epub: Path) -> None:
        """Test outputlist with single chapter."""
        chapters = cast(list[str], epub2txt(str(single_chapter_epub), outputlist=True))

        assert len(chapters) >= 1
        assert any("only chapter" in ch.lower() for ch in chapters if ch)

    def test_file_not_found(self) -> None:
        """Test that FileNotFoundError is raised for missing files."""
        with pytest.raises(FileNotFoundError):
            EPUBParser("/nonexistent/path/to/book.epub")

    def test_invalid_epub(self, tmp_path: Path) -> None:
        """Test that invalid EPUB raises appropriate error."""
        # Create a fake file that's not a valid EPUB
        fake_epub = tmp_path / "fake.epub"
        fake_epub.write_text("This is not an EPUB file")

        with pytest.raises((ValueError, Exception)):
            EPUBParser(str(fake_epub))


class TestHTMLContent:
    """Test EPUB generation with various HTML structures."""

    @pytest.fixture
    def ordered_list_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with ordered lists."""
        epub_path = tmp_path / "ordered_list_book.epub"

        book = pypub.Epub("Ordered List Test", creator="List Author")

        html_content = b"""
        <html>
        <body>
            <h1>Instructions</h1>
            <p>Follow these steps:</p>
            <ol>
                <li>First step of the process</li>
                <li>Second step comes next</li>
                <li>Third step follows</li>
                <li>Fourth and final step</li>
            </ol>
            <p>That completes the instructions.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Step by Step",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def mixed_content_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with mixed HTML content."""
        epub_path = tmp_path / "mixed_content_book.epub"

        book = pypub.Epub("Mixed Content Test", creator="Mixed Author")

        html_content = b"""
        <html>
        <body>
            <h1>Mixed Content Chapter</h1>
            <p>This chapter has various content types.</p>

            <h2>A Subsection</h2>
            <p>With its own paragraph.</p>

            <blockquote>
                <p>A quote from someone important.</p>
            </blockquote>

            <p>Back to regular content.</p>

            <pre>Some preformatted text
            that preserves spacing</pre>

            <p>Final paragraph.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Mixed Content",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_ordered_list_extraction(self, ordered_list_epub: Path) -> None:
        """Test that ordered lists are extracted."""
        text = cast(str, epub2txt(str(ordered_list_epub)))

        # List items should be present
        assert "first step" in text.lower()
        assert "fourth" in text.lower()

    def test_mixed_content_extraction(self, mixed_content_epub: Path) -> None:
        """Test extraction of mixed HTML content."""
        text = cast(str, epub2txt(str(mixed_content_epub)))

        # Various content types should be present
        assert "subsection" in text.lower()
        assert "quote" in text.lower()
        assert "final paragraph" in text.lower()


class TestFormatStyles:
    """Test different format styles (compact vs readable)."""

    @pytest.fixture
    def multi_paragraph_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with multiple paragraphs for format testing."""
        epub_path = tmp_path / "format_test_book.epub"

        book = pypub.Epub("Format Test Book", creator="Format Author")

        # Create content with clear paragraph structure
        html_content = b"""
        <html>
        <body>
            <p>First paragraph of the chapter with some content.</p>
            <p>Second paragraph follows the first one.</p>
            <p>Third paragraph is here as well.</p>
            <p>Fourth paragraph continues the text.</p>
            <p>Fifth and final paragraph ends this chapter.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Format Test Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_compact_format_uses_single_newlines(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that compact format uses single newlines between paragraphs."""
        parser = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        chapters = parser.get_chapters()

        # Get text from first chapter with content
        text = ""
        for ch in chapters:
            if ch.text:
                text = ch.text
                break

        # Compact format: paragraphs separated by single newlines
        # Should have newlines in the text
        assert "\n" in text or len(text) > 0
        # Count lines - should have at least 1 line with content
        line_count = len([line for line in text.split("\n") if line.strip()])
        assert line_count >= 1  # At least some content

    def test_readable_format_uses_double_newlines(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that readable format uses double newlines between paragraphs."""
        parser = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n\n")
        chapters = parser.get_chapters()

        # Get text from first chapter with content
        text = ""
        for ch in chapters:
            if ch.text:
                text = ch.text
                break

        # Readable format: paragraphs separated by double newlines
        assert "\n\n" in text or len(text.split("\n")) >= 1

    def test_compact_has_more_lines_than_readable(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that compact format produces more lines than readable format."""
        from epub2text.cleaner import TextCleaner

        # Extract with compact settings
        parser_compact = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        chapters_compact = parser_compact.get_chapters()
        text_compact = ""
        for ch in chapters_compact:
            if ch.text:
                text_compact = ch.text
                break

        cleaner_compact = TextCleaner(preserve_single_newlines=True)
        cleaned_compact = cleaner_compact.clean(text_compact)

        # Extract with readable settings
        parser_readable = EPUBParser(
            str(multi_paragraph_epub), paragraph_separator="\n\n"
        )
        chapters_readable = parser_readable.get_chapters()
        text_readable = ""
        for ch in chapters_readable:
            if ch.text:
                text_readable = ch.text
                break

        cleaner_readable = TextCleaner(preserve_single_newlines=False)
        cleaned_readable = cleaner_readable.clean(text_readable)

        # Count non-empty lines
        compact_lines = len([l for l in cleaned_compact.split("\n") if l.strip()])
        readable_lines = len([l for l in cleaned_readable.split("\n") if l.strip()])

        # Compact should have at least as many lines (typically more due to
        # single newline separation)
        # Note: This depends on content structure
        assert compact_lines >= 1
        assert readable_lines >= 1

    def test_paragraph_separator_affects_output(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that paragraph_separator parameter affects the output."""
        parser_single = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        parser_double = EPUBParser(
            str(multi_paragraph_epub), paragraph_separator="\n\n"
        )

        chapters_single = parser_single.get_chapters()
        chapters_double = parser_double.get_chapters()

        # Both should extract content
        assert len(chapters_single) >= 1
        assert len(chapters_double) >= 1

        # Get text from chapters
        text_single = ""
        text_double = ""
        for ch in chapters_single:
            if ch.text:
                text_single = ch.text
                break
        for ch in chapters_double:
            if ch.text:
                text_double = ch.text
                break

        # Both should have content
        assert len(text_single) > 0
        assert len(text_double) > 0


class TestTextCleaner:
    """Test the TextCleaner class directly."""

    def test_preserve_single_newlines_true(self) -> None:
        """Test that preserve_single_newlines=True keeps single newlines."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=True)
        text = "Line one.\nLine two.\nLine three."
        result = cleaner.clean(text)

        # Single newlines should be preserved
        assert "\n" in result
        assert "Line one." in result
        assert "Line two." in result

    def test_preserve_single_newlines_false(self) -> None:
        """Test that preserve_single_newlines=False replaces single newlines."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(
            preserve_single_newlines=False, replace_single_newlines=True
        )
        text = "Line one.\nLine two.\nLine three."
        result = cleaner.clean(text)

        # Single newlines should be replaced with spaces
        assert (
            "Line one. Line two. Line three." in result
            or "\n" not in result.replace("\n\n", "")
        )

    def test_multiple_newlines_collapsed_compact(self) -> None:
        """Test that multiple newlines are collapsed to single in compact mode."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=True)
        text = "Para one.\n\n\n\nPara two."
        result = cleaner.clean(text)

        # Multiple newlines should become single newline
        assert "\n\n\n" not in result

    def test_multiple_newlines_collapsed_readable(self) -> None:
        """Test that multiple newlines are collapsed to double in readable mode."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=False)
        text = "Para one.\n\n\n\nPara two."
        result = cleaner.clean(text)

        # Multiple newlines should become exactly two
        assert "\n\n\n" not in result

    def test_remove_footnotes(self) -> None:
        """Test footnote removal."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_footnotes=True)
        text = "This is text [1] with footnotes [23] in it."
        result = cleaner.clean(text)

        assert "[1]" not in result
        assert "[23]" not in result
        assert "This is text" in result

    def test_keep_footnotes(self) -> None:
        """Test keeping footnotes when disabled."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_footnotes=False, remove_page_numbers=False)
        text = "This is text [1] with footnotes [23] in it."
        result = cleaner.clean(text)

        assert "[1]" in result
        assert "[23]" in result

    def test_remove_page_numbers_standalone(self) -> None:
        """Test removal of standalone page numbers."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_page_numbers=True)
        text = "Some text.\n42\nMore text."
        result = cleaner.clean(text)

        # Standalone "42" should be removed
        lines = [l.strip() for l in result.split("\n") if l.strip()]
        assert "42" not in lines

    def test_normalize_whitespace(self) -> None:
        """Test whitespace normalization."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(normalize_whitespace=True)
        text = "Text   with    multiple     spaces."
        result = cleaner.clean(text)

        assert "   " not in result
        assert "Text with multiple spaces." in result

    def test_calculate_length(self) -> None:
        """Test text length calculation."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner()
        text = "Hello World"
        length = cleaner.calculate_length(text)

        # calculate_length removes newlines but keeps other characters
        assert length == len("Hello World")  # Spaces are kept, newlines stripped

    def test_clean_text_function(self) -> None:
        """Test the clean_text convenience function."""
        from epub2text.cleaner import clean_text

        text = "Some   text [1] with\n\n\n\nmultiple issues."
        result = clean_text(text)

        # Should clean up various issues
        assert "   " not in result
        assert "[1]" not in result
        assert "\n\n\n" not in result
